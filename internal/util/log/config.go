package log

import (
	"fmt"
	"log"
	"os"
	"os/user"
	"path/filepath"
	"strconv"
	"sync"
	"time"
)

var (
	fileNameTimeFormat  = "2006-01-02_150405"
	logPrefixTimeFormat = "2006-01-02:15:04:05.000"
	once                sync.Once

	pid      int
	host     string
	username string
)

func defaultLogPrefix(level string) string {
	logTimestamp := time.Now().Format(logPrefixTimeFormat)
	return fmt.Sprintf("%s %s", logTimestamp, fmt.Sprintf(logfd.header, level))
}

func init() {
	host, _ = os.Hostname()
	pid = os.Getpid()
	currentUser, _ := user.Current()
	username = currentUser.Username
}

type (
	Config struct {
		app      string
		dir      string
		filename string

		prefix     string
		prefixFunc func(string) string

		shellVerbosity Level
		fileVerbosity  Level
		onlyToStd      bool
		alsoToStd      bool

		color  bool
	}

	Option func(*Config)
)

func WithColor() Option {
	return func(cfg *Config) {
		cfg.color = true
	}
}

func WithAlsoToStd() Option {
	return func(cfg *Config) {
		cfg.alsoToStd = true
	}
}

func WithFileLevel(level Level) Option {
	return func(cfg *Config) {
		if level < LOGERROR {
			level = LOGERROR
		}
		if level > LOGDEBUG {
			level = LOGDEBUG
		}
		cfg.fileVerbosity = level
	}
}

func WithStdLevel(level Level) Option {
	return func(cfg *Config) {
		if level < LOGERROR {
			level = LOGERROR
		}
		if level > LOGDEBUG {
			level = LOGDEBUG
		}
		cfg.shellVerbosity = level
	}
}

func Init(app string, opts ...Option) error {
	var errOutside error
	once.Do(func() {
		var err error
		defer func() {
			errOutside = err
		}()

		cfg := Config{
			dir:            tempDir(),
			app:            app,
			fileVerbosity:  LOGINFO,
			shellVerbosity: LOGDEBUG,
			prefixFunc:     defaultLogPrefix,
		}
		for _, applyFn := range opts {
			applyFn(&cfg)
		}

		fwriter, err := getDefaultLogFile(cfg.dir, cfg.app)
		if err != nil {
			return
		}
		cfg.filename = fwriter.Name()

		initLogger := func() *mxLogger {
			tmp := &mxLogger{
				Config: cfg,
				stdout: log.New(os.Stdout, "", 0),
				stderr: log.New(os.Stderr, "", 0),
				file:   log.New(fwriter, "", 0),
				header: generateHeader(cfg.app),
			}

			tmp.stdout.SetFlags(log.Lshortfile)
			tmp.stderr.SetFlags(log.Lshortfile)
			tmp.file.SetFlags(log.Lshortfile)

			return tmp
		}
		tmp := initLogger()


		if tmp == nil {
			err = fmt.Errorf("logger is nil and could not be initialized again")
			return
		}
		logfd = tmp
	})
	return errOutside
}

func getDefaultLogFile(logDir, app string) (*os.File, error) {
	if len(logDir) == 0 {
		logDir = tempDir()
	}
	err := os.MkdirAll(logDir, os.FileMode(0755))
	if err != nil {
		return nil, fmt.Errorf("error cannot create log dir %s, %s", logDir, err)
	}
	logFilePath := generateLogFileName(logDir, app)
	flags := os.O_APPEND | os.O_CREATE | os.O_WRONLY
	logFile, err := os.OpenFile(logFilePath, flags, 0644)
	if err != nil {
		return nil, fmt.Errorf("error creating log file %s, %s", logDir, err)
	}
	return logFile, nil
}

func generateLogFileName(logDir, app string) string {
	// Append pid to the tail of a log file to identify unique log
	// file name that has been generated by each process at some time
	return filepath.Join(logDir, fmt.Sprintf("%s.%s-%s.log", app, now().Format(fileNameTimeFormat), strconv.Itoa(pid)))
}

func generateHeader(application string) string {
	headerFormatStr := "%s:%s:%s:%06d-[%s]:-" // APPLICATIONNAME:USERNAME:HOSTNAME:PID-[LOGLEVEL]:-
	header := fmt.Sprintf(headerFormatStr, application, username, host, pid, "%s")
	return header
}

// tempDir() On OSX os.TempDir() returns something like /var/folders/bw/55s7r48s413gj27l6558lxg40000gp/T/
// This is annoying for development or debugging, so on OSX we force it to /tmp
func tempDir() string {
	return "/tmp"
}
